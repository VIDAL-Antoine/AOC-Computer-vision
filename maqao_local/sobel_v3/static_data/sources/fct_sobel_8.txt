/usr/include/x86_64-linux-gnu/bits/stdio2.h: 105 - 105
--------------------------------------------------------------------------------

105:   return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
/home/vidal/Desktop/AOC_oseret/Projet/AOC-Computer-vision/rdtsc.h: 9 - 11
--------------------------------------------------------------------------------

9:   __asm__ volatile ("rdtsc" : "=a" (a), "=d" (d));
10: 
11:   return (d << 32) | a;
/home/vidal/Desktop/AOC_oseret/Projet/AOC-Computer-vision/sobel.c: 21 - 300
--------------------------------------------------------------------------------

21:   u8 *p_frame = __builtin_assume_aligned(frame, 32);
22:   for (u64 i = 0; i < H * W * 3; i += 3)
23:     {
24:       //Convert RGB color values into grayscale for each pixel using color weights
25:       //Other possible weights: 0.59, 0.30, 0.11
26:       //Principle: mix different quantities of R, G, B to create a variant of gray
27:       gray = ((float)p_frame[i] * 0.299) + ((float)p_frame[i + 1] * 0.587) + ((float)p_frame[i + 2] * 0.114);
28:       
29:       p_frame[i]     = gray;
[...]
203:   u8 *p_oframe = __builtin_assume_aligned(oframe, 32);
204:   //
205:   for (u32 i = 0; i < H3; i++)
206:   {
207:     for (u32 j = 0; j < W3_3; j++)
208:     {
209:       u32 gx, i_W3_j, mag_approx; //gy is stored in mag_approx
210:       i_W3_j = i * W3 + j;
211: 
212:       gx = ( p_cframe[i_W3_j + 8] - p_cframe[i_W3_j] );
213:       mag_approx = gx;
214:       gx         +=   p_cframe[i_W3_j + 2] - p_cframe[i_W3_j + 6] + 2 * ( p_cframe[i_W3_j + 5] - p_cframe[i_W3_j + 3] );
215:       mag_approx += - p_cframe[i_W3_j + 2] + p_cframe[i_W3_j + 6] + 2 * ( p_cframe[i_W3_j + 7] - p_cframe[i_W3_j + 1] );
216:       mag_approx = abs(mag_approx) + abs(gx);
217:       p_oframe[i_W3_j] = (mag_approx > THRESHOLD) ? 255 : (mag_approx);
[...]
266:   #pragma omp parallel for shared(cframe, oframe, cycles, samples_count, frame_count, nb_bytes)
[...]
290:       u64 elapsed = (cycles_a - cycles_b);
291: 
292:       //
293:       if (samples_count < MAX_SAMPLES)
294: 	      cycles[samples_count++] = elapsed;
295:       
296:       //frame number; size in Bytes; elapsed cycles; bytes per cycle
297:       fprintf(stdout, "%20llu; %20llu; %20llu; %15.3lf\n", frame_count, nb_bytes, elapsed, (f64)(nb_bytes) / (f64)elapsed);
298: 
299:       //
300:       frame_count++;
